import { ValidateError } from "./validateError";

export class ValidateResult<T> {
    /**
     * All grouped errors generated by current validation
     */
    public errors: Map<keyof T, ValidateError[]>;
    /**
     * The validated instance object.
     */
    public value: T;
    /**
     * The first's error message
     */
    public message: string;
    constructor(value: T, errors: Map<keyof T, ValidateError[]>) {
        this.errors = errors;
        this.value = value;
        if (this.hasError()) {
            this.message = this.toSingle().message;
        }
    }
    /**
     * Get all errors by special property name.
     * @param property property name
     */
    public getErrors(property: keyof T): ValidateError[] {
        if (this.hasError(property)) {
            return this.errors.get(property);
        } else {
            return [];
        }
    }
    /**
     * Get error by property name and error type.
     * @param property property name
     * @param errorType error type
     */
    public getError(property: keyof T, errorType: string): ValidateError | null {
        if (this.hasError(property, errorType)) {
            return this.errors.get(property).find((e) => e.type === errorType);
        } else {
            return null;
        }
    }
    /**
     * Determine if there is a specified type of error on a specified property.
     * If the error type is omitted, it is judged whether there is any type of error on the specified property.
     * If the property name is also omitted, it is judged whether or not it contains any error.
     * @param property property name
     * @param errorType error type
     */
    public hasError(property?: keyof T, errorType?: string): boolean {
        if (this.errors instanceof Map) {
            if (property) {
                if (errorType) {
                    return this.errors.has(property) && this.errors.get(property).some((e) => e.type === errorType);
                } else {
                    return this.errors.has(property);
                }
            } else {
                return this.errors.size > 0;
            }
        }
        return false;
    }
    /**
     * Convert errors to the specified type based on a custom function.
     * @param callback custom convert function.
     */
    public map(callback: (errors: Map<keyof T, ValidateError[]>) => any) {
        if (typeof callback === "function") {
            return callback(this.errors);
        } else {
            return this.errors;
        }
    }
    /**
     * Convert the current grouping errors into a list form.
     */
    public toList(): ValidateError[] {
        if (this.hasError()) {
            const list: ValidateError[] = [];
            this.errors.forEach((errors) => errors.forEach((error) => list.push(error)));
            return list;
        }
        return [];
    }
    /**
     * Convert the current grouping errors into a single error object.
     */
    public toSingle(): ValidateError | null {
        if (this.hasError()) {
            for (const errors of this.errors.values()) {
                return errors[0];
            }
        }
        return null;
    }
}
