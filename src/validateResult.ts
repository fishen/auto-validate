import { ValidateError } from "./validateError";

export class ValidateResult<T> {
    /**
     * All grouped errors generated by current validation
     */
    public errors: Map<keyof T, ValidateError[]>;
    /**
     * The validated instance object.
     */
    public value: T;
    constructor(value: T, errors: Map<keyof T, ValidateError[]>) {
        this.errors = errors;
        this.value = value;
    }
    /**
     * Get all errors by special property name.
     * @param property property name
     */
    getErrors(property: keyof T): ValidateError[] {
        if (this.hasError(property)) {
            return this.errors.get(property);
        } else {
            return [];
        }
    }
    /**
     * Get error by property name and error type.
     * @param property property name
     * @param errorType error type
     */
    getError(property: keyof T, errorType: string): ValidateError | null {
        if (this.hasError(property, errorType)) {
            return this.errors.get(property).find(e => e.type === errorType);
        } else {
            return null;
        }
    }
    /**
     * Determine if there is a specified type of error on a specified property.
     * If the error type is omitted, it is judged whether there is any type of error on the specified property.
     * If the property name is also omitted, it is judged whether or not it contains any error.
     * @param property property name
     * @param errorType error type
     */
    hasError(property?: keyof T, errorType?: string): boolean {
        if (this.errors instanceof Map) {
            if (property) {
                if (errorType) {
                    return this.errors.has(property) && this.errors.get(property).some(e => e.type === errorType);
                } else {
                    return this.errors.has(property);
                }
            } else {
                return this.errors.size > 0;
            }
        };
        return false;
    }
    /**
     * Convert errors to the specified type based on a custom function.
     * @param callback custom convert function.
     */
    map(callback: (errors: Map<keyof T, ValidateError[]>) => any) {
        if (typeof callback === 'function') {
            return callback(this.errors);
        } else {
            return this.errors;
        }
    }
    /**
     * Convert the current grouping errors into a list form.
     */
    toList(): ValidateError[] {
        if (this.hasError()) {
            let list: ValidateError[] = [];
            this.errors.forEach((errors) => errors.forEach(error => list.push(error)));
            return list;
        }
        return [];
    }
    /**
     * Convert the current grouping errors into a single error object.
     */
    toSingle(): ValidateError | null {
        if (this.hasError()) {
            for (const errors of this.errors.values()) {
                return errors[0];
            }
        }
        return null;
    }
}